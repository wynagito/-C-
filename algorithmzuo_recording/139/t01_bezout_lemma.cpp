// 裴蜀定理
// 如果a和b是不全为0的整数，则有整数x、y，使得ax + by = gcd(a,b)
// 课上重点图解证明过程，证明很重要，可以帮助理解扩展欧几里得算法的过程

// 重要理解
// a和b的最大公约数 = ax + by，随意给定整数x、y，能得到的最小正整数
// a和b的最大公约数 = ax和by，随意给定整数x、y，能得到的最小正数差值

// 裴蜀定理推论
// 1，如果a和b是不全为0的整数，a和b互质，当且仅当存在整数x、y，使ax + by = 1
// 2，如果a和b是不全为0的整数，并且ax + by = c有解，那么c一定是gcd(a,b)的整数倍
// 3，a和b两项的裴蜀定理，可以推广到多项的情况

// 如果ax + by = c一旦有解，就意味着一定有无穷多组(x,y)，都可以使得式子成立

// 扩展欧几里得算法
// 对于方程ax + by = gcd(a,b)，当a和b确定，那么gcd(a,b)也确定，要保证入参a和b没有负数
// 扩展欧几里得算法可以给出a和b的最大公约数d、以及其中一个特解x、y
// 课上重点图解，理解了裴蜀定理证明，也就理解了扩展欧几里得算法过程的正确性

// 时间复杂度
// 扩展欧几里得算法理论的时间复杂度O(log min{a,b})，但要注意%运算的代价比较高
// 所以实际的时间复杂度O((log min{a,b})的三次方)，证明略，知道极快即可

// 求逆元
// 费马小定理求逆元时，要求模的数字必须为质数
// 扩展欧几里得算法求逆元时，不要求模的数字必须为质数，但要求a和b互质

// 裴蜀定理模版题
// 给定长度为n的一组整数值[a1, a2, a3...]，你找到一组数值[x1, x2, x3...]
// 要让a1*x1 + a2*x2 + a3*x3...得到的结果为最小正整数
// 返回能得到的最小正整数是多少
// 1 <= n <= 20
// 1 <= ai <= 10^5
// 测试链接 : https://www.luogu.com.cn/problem/P4549

#include <iostream>
#include <cmath>

using namespace std;

int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}

int main()
{
    int n;
    int ans = 0;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        int a;
        cin >> a;
        ans = gcd(ans, abs(a));
    }
    cout << ans << endl;
    return 0;
}