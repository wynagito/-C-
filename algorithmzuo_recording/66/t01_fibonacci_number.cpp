// 动态规划：用空间代替重复计算，包含一整套原理和技巧的总和，课程会用非常大的篇幅来全盘介绍

// 知道怎么算的算法 vs 知道怎么试的算法

//  有些递归在展开计算时，总是重复调用同一个子问题的解，这种重复调用的递归变成动态规划很有收益
//  如果每次展开都是不同的解，或者重复调用的现象很少，那么没有改动态规划的必要
// 下节课会举例，哪些递归没有必要改动态规划的必要

// 任何动态规划问题都一定对应着一个有重复调用行为的递归
// 所以任何动态规划的题目都一定可以从递归入手，逐渐实现动态规划的方法
// 题目1到题目4，都从递归入手，逐渐改出动态规划的实现

// 尝试策略 就是 转移方程，完全一回事！ 推荐从尝试入手，因为代码好写，并且一旦发现尝试错误，重新想别的递归代价轻！

// 当熟悉了从递归到动态规划的转化过程
// 那么就可以纯粹用动态规划的视角来分析问题了
// 题目5到题目8，都是纯粹用动态规划的视角来分析、优化的

// 如果不熟悉这个过程，直接一上来就硬去理解状态转移方程
// 那么往往会步履维艰、邯郸学步、东施效颦
// 这是多年教学看到的真实情况

// 很多极为优异的想法、设计和优化 来自 努力 or 天赋

// 建议脚踏实地，真正做好从递归到动态规划的练习
// 接下来的几节课也都会从最基本递归入手，逐渐写出动态规划的版本

// 动态规划的大致过程：
// 想出设计优良的递归尝试(方法、经验、固定套路很多)，有关尝试展开顺序的说明
// -> 记忆化搜索(从顶到底的动态规划) ，如果每个状态的计算枚举代价很低，往往到这里就可以了
// -> 严格位置依赖的动态规划(从底到顶的动态规划) ，更多是为了下面说的 进一步优化枚举做的准备
// -> 进一步优化空间（空间压缩），一维、二维、多维动态规划都存在这种优化
// -> 进一步优化枚举也就是优化时间（本节没有涉及，但是后续巨多内容和这有关）

// 解决一个问题，可能有很多尝试方法
// 众多的尝试方法中，可能若干的尝试方法有重复调用的情况，可以转化成动态规划
// 若干个可以转化成动态规划的方法中，又可能有优劣之分
// 判定哪个是最优的动态规划方法，依据来自题目具体参数的数据量
// 最优的动态规划方法实现后，后续又有一整套的优化技巧

// 斐波那契数
// 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列
// 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。
// 也就是：F(0) = 0，F(1) = 1
// F(n) = F(n - 1) + F(n - 2)，其中 n > 1
// 给定 n ，请计算 F(n)
// 测试链接 : https://leetcode.cn/problems/fibonacci-number/

class Solution
{
public:
    int fib1(int n)
    {
        return f1(n);
    }

    int f1(int i)
    {
        if (i == 0)
        {
            return 0;
        }
        if (i == 1)
        {
            return 1;
        }
        return f1(i - 1) + f1(i - 2);
    }

    int fib2(int n)
    {
        vector<int> dp(n + 1, -1);
        return f2(n, dp);
    }

    int f2(int i, vector<int> &dp)
    {
        if (i == 0)
        {
            return 0;
        }
        if (i == 1)
        {
            return 1;
        }
        if (dp[i] != -1)
        {
            return dp[i];
        }
        int ans = f2(i - 1, dp) + f2(i - 2, dp);
        dp[i] = ans;
        return ans;
    }

    int fib3(int n)
    {
        if (n == 0)
        {
            return 0;
        }
        if (n == 1)
        {
            return 1;
        }
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

    int fib4(int n)
    {
        if (n == 0)
        {
            return 0;
        }
        if (n == 1)
        {
            return 1;
        }
        int lastLast = 0, last = 1;
        for (int i = 2, cur; i <= n; i++)
        {
            cur = lastLast + last;
            lastLast = last;
            last = cur;
        }
        return last;
    }
};