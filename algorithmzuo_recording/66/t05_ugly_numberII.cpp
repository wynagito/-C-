// 丑数 II
// 给你一个整数 n ，请你找出并返回第 n 个 丑数
// 丑数 就是只包含质因数 2、3 或 5 的正整数
// 测试链接 : https://leetcode.cn/problems/ugly-number-ii/

class Solution
{
public:
    int dp[1700];
    int nthUglyNumber(int n)
    {
        // 暴力思路
        // 前面的数都乘2 3 5 得到的数 选取不小于前面数的最小的
        // eg 1
        // 1 * 2 = 2 1 * 3 = 3 1 * 5 = 5 最小的 2
        // 1 2
        // 1 * 2 = 2 1 * 3 = 3 1 * 5 = 5 2 * 2 = 4 2 * 3 = 6 2 * 5 = 10 最小的 3
        // 1 2 3

        // 由此可以启发 单调性
        // 选取2 之后 1 就不用再乘2了
        // 让乘2的指针下移
        // 选取3 之后 1 就不用再乘3了
        // 让乘3的指针下移

        // dp 0 1 2 ...  n
        //      1 2 ...  ?
        dp[1] = 1;
        // i2 乘2的指针
        // i3 乘3的指针
        // i5 乘5的指针
        // cur 当前丑数
        // a b c 三个指针指向的丑数
        for (int i = 2, i2 = 1, i3 = 1, i5 = 1, a, b, c, cur; i <= n; i++)
        {
            a = dp[i2] * 2;
            b = dp[i3] * 3;
            c = dp[i5] * 5;
            cur = min(min(a, b), c);
            // 指针移动
            // 最小值指针移动
            // 保证单调性
            if (cur == a)
            {
                i2++;
            }
            if (cur == b)
            {
                i3++;
            }
            if (cur == c)
            {
                i5++;
            }
            dp[i] = cur;
        }
        return dp[n];
    }
};